{
  "rust": {
    "api": "use axum::{routing::get, Router, Json};\nuse serde::{Deserialize, Serialize};\nuse tokio::net::TcpListener;\n\n#[derive(Serialize, Deserialize)]\nstruct ApiResponse {\n    message: String,\n    data: Option<serde_json::Value>,\n}\n\nasync fn health_check() -> Json<ApiResponse> {\n    Json(ApiResponse {\n        message: \"POC API is running\".to_string(),\n        data: None,\n    })\n}\n\n#[tokio::main]\nasync fn main() {\n    let app = Router::new()\n        .route(\"/health\", get(health_check));\n    \n    let listener = TcpListener::bind(\"0.0.0.0:3000\").await.unwrap();\n    println!(\"POC server running on http://0.0.0.0:3000\");\n    \n    axum::serve(listener, app).await.unwrap();\n}",
    "cli": "use clap::Parser;\n\n#[derive(Parser, Debug)]\n#[command(author, version, about, long_about = None)]\nstruct Args {\n    /// Input file to process\n    #[arg(short, long)]\n    input: Option<String>,\n    \n    /// Enable verbose output\n    #[arg(short, long)]\n    verbose: bool,\n}\n\nfn main() {\n    let args = Args::parse();\n    \n    if let Some(input) = args.input {\n        println!(\"Processing file: {}\", input);\n    }\n    \n    if args.verbose {\n        println!(\"Verbose mode enabled\");\n    }\n}",
    "service": "use std::sync::Arc;\nuse tokio::sync::Mutex;\n\n#[derive(Clone)]\nstruct ServiceState {\n    // Add your state fields here\n    counter: Arc<Mutex<u64>>,\n}\n\nimpl ServiceState {\n    fn new() -> Self {\n        Self {\n            counter: Arc::new(Mutex::new(0)),\n        }\n    }\n    \n    async fn process(&self) -> Result<(), Box<dyn std::error::Error>> {\n        let mut count = self.counter.lock().await;\n        *count += 1;\n        println!(\"Processed {} items\", *count);\n        Ok(())\n    }\n}\n\n#[tokio::main]\nasync fn main() {\n    let service = ServiceState::new();\n    \n    // Run your service logic here\n    service.process().await.unwrap();\n}"
  },
  "javascript": {
    "api": "const express = require('express');\nconst app = express();\nconst port = process.env.PORT || 3000;\n\napp.use(express.json());\n\n// Health check endpoint\napp.get('/health', (req, res) => {\n  res.json({\n    message: 'POC API is running',\n    timestamp: new Date().toISOString(),\n    uptime: process.uptime()\n  });\n});\n\n// Example API endpoint\napp.post('/api/example', async (req, res) => {\n  try {\n    const { data } = req.body;\n    \n    // Process your data here\n    const result = {\n      received: data,\n      processed: true,\n      timestamp: new Date().toISOString()\n    };\n    \n    res.json({ success: true, result });\n  } catch (error) {\n    res.status(500).json({ success: false, error: error.message });\n  }\n});\n\napp.listen(port, () => {\n  console.log(`POC server running on port ${port}`);\n});",
    "cli": "#!/usr/bin/env node\n\nconst { program } = require('commander');\nconst fs = require('fs').promises;\nconst path = require('path');\n\nprogram\n  .version('1.0.0')\n  .description('POC CLI tool')\n  .option('-i, --input <file>', 'input file to process')\n  .option('-o, --output <file>', 'output file')\n  .option('-v, --verbose', 'enable verbose output')\n  .parse(process.argv);\n\nconst options = program.opts();\n\nasync function main() {\n  try {\n    if (options.input) {\n      if (options.verbose) console.log(`Reading file: ${options.input}`);\n      \n      const content = await fs.readFile(options.input, 'utf-8');\n      \n      // Process content here\n      const processed = content.toUpperCase();\n      \n      if (options.output) {\n        await fs.writeFile(options.output, processed);\n        console.log(`Output written to: ${options.output}`);\n      } else {\n        console.log(processed);\n      }\n    } else {\n      program.help();\n    }\n  } catch (error) {\n    console.error('Error:', error.message);\n    process.exit(1);\n  }\n}\n\nmain();",
    "webapp": "import React, { useState, useEffect } from 'react';\nimport './App.css';\n\nfunction App() {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    fetchData();\n  }, []);\n\n  const fetchData = async () => {\n    try {\n      const response = await fetch('/api/data');\n      if (!response.ok) throw new Error('Failed to fetch');\n      \n      const result = await response.json();\n      setData(result);\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error}</div>;\n\n  return (\n    <div className=\"App\">\n      <h1>POC Web App</h1>\n      <pre>{JSON.stringify(data, null, 2)}</pre>\n    </div>\n  );\n}\n\nexport default App;"
  },
  "typescript": {
    "api": "import express, { Request, Response } from 'express';\nimport { z } from 'zod';\n\nconst app = express();\nconst port = process.env.PORT || 3000;\n\napp.use(express.json());\n\n// Request validation schema\nconst ExampleRequestSchema = z.object({\n  data: z.string(),\n  options: z.object({\n    format: z.enum(['json', 'text']).optional(),\n  }).optional(),\n});\n\ntype ExampleRequest = z.infer<typeof ExampleRequestSchema>;\n\n// Health check\napp.get('/health', (req: Request, res: Response) => {\n  res.json({\n    message: 'POC API is running',\n    timestamp: new Date().toISOString(),\n    uptime: process.uptime(),\n  });\n});\n\n// Example endpoint with validation\napp.post('/api/example', async (req: Request, res: Response) => {\n  try {\n    const validatedData = ExampleRequestSchema.parse(req.body);\n    \n    // Process your data here\n    const result = {\n      received: validatedData.data,\n      format: validatedData.options?.format || 'json',\n      processed: true,\n      timestamp: new Date().toISOString(),\n    };\n    \n    res.json({ success: true, result });\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      res.status(400).json({ success: false, errors: error.errors });\n    } else {\n      res.status(500).json({ success: false, error: 'Internal server error' });\n    }\n  }\n});\n\napp.listen(port, () => {\n  console.log(`POC server running on port ${port}`);\n});",
    "service": "interface ServiceConfig {\n  name: string;\n  maxRetries: number;\n  timeout: number;\n}\n\nclass POCService {\n  private config: ServiceConfig;\n  private isRunning: boolean = false;\n\n  constructor(config: ServiceConfig) {\n    this.config = config;\n  }\n\n  async start(): Promise<void> {\n    if (this.isRunning) {\n      throw new Error('Service is already running');\n    }\n\n    this.isRunning = true;\n    console.log(`Starting ${this.config.name} service...`);\n\n    // Implement your service logic here\n    await this.processLoop();\n  }\n\n  async stop(): Promise<void> {\n    this.isRunning = false;\n    console.log(`Stopping ${this.config.name} service...`);\n  }\n\n  private async processLoop(): Promise<void> {\n    while (this.isRunning) {\n      try {\n        await this.processItem();\n        await this.sleep(1000); // Process every second\n      } catch (error) {\n        console.error('Error in process loop:', error);\n      }\n    }\n  }\n\n  private async processItem(): Promise<void> {\n    // Implement your processing logic here\n    console.log('Processing item...');\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n\n// Usage\nconst service = new POCService({\n  name: 'POC',\n  maxRetries: 3,\n  timeout: 5000,\n});\n\nservice.start().catch(console.error);"
  },
  "python": {
    "api": "from flask import Flask, jsonify, request\nfrom datetime import datetime\nimport os\n\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    return jsonify({\n        'message': 'POC API is running',\n        'timestamp': datetime.now().isoformat(),\n        'version': '1.0.0'\n    })\n\n@app.route('/api/example', methods=['POST'])\ndef example_endpoint():\n    try:\n        data = request.get_json()\n        \n        # Process your data here\n        result = {\n            'received': data,\n            'processed': True,\n            'timestamp': datetime.now().isoformat()\n        }\n        \n        return jsonify({'success': True, 'result': result})\n    except Exception as e:\n        return jsonify({'success': False, 'error': str(e)}), 500\n\nif __name__ == '__main__':\n    port = int(os.environ.get('PORT', 3000))\n    app.run(host='0.0.0.0', port=port, debug=True)",
    "cli": "#!/usr/bin/env python3\n\nimport argparse\nimport sys\nimport json\nfrom pathlib import Path\n\ndef main():\n    parser = argparse.ArgumentParser(description='POC CLI tool')\n    parser.add_argument('-i', '--input', type=str, help='Input file to process')\n    parser.add_argument('-o', '--output', type=str, help='Output file')\n    parser.add_argument('-f', '--format', choices=['json', 'text'], default='text', help='Output format')\n    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')\n    \n    args = parser.parse_args()\n    \n    if not args.input:\n        parser.print_help()\n        sys.exit(1)\n    \n    try:\n        if args.verbose:\n            print(f\"Reading file: {args.input}\")\n        \n        with open(args.input, 'r') as f:\n            content = f.read()\n        \n        # Process content here\n        if args.format == 'json':\n            result = {\n                'input': args.input,\n                'lines': len(content.splitlines()),\n                'characters': len(content)\n            }\n            output = json.dumps(result, indent=2)\n        else:\n            output = f\"Processed {len(content)} characters from {args.input}\"\n        \n        if args.output:\n            with open(args.output, 'w') as f:\n                f.write(output)\n            print(f\"Output written to: {args.output}\")\n        else:\n            print(output)\n            \n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n        sys.exit(1)\n\nif __name__ == '__main__':\n    main()",
    "service": "import asyncio\nimport signal\nimport logging\nfrom typing import Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass ServiceConfig:\n    name: str\n    interval: float = 1.0\n    max_retries: int = 3\n\nclass POCService:\n    def __init__(self, config: ServiceConfig):\n        self.config = config\n        self.running = False\n        self.tasks: list[asyncio.Task] = []\n        \n    async def start(self):\n        \"\"\"Start the service\"\"\"\n        if self.running:\n            raise RuntimeError(\"Service is already running\")\n            \n        self.running = True\n        logger.info(f\"Starting {self.config.name} service...\")\n        \n        # Set up signal handlers\n        for sig in (signal.SIGTERM, signal.SIGINT):\n            signal.signal(sig, self._signal_handler)\n        \n        # Start processing\n        await self._process_loop()\n        \n    def _signal_handler(self, signum, frame):\n        \"\"\"Handle shutdown signals\"\"\"\n        logger.info(f\"Received signal {signum}, shutting down...\")\n        self.running = False\n        \n    async def _process_loop(self):\n        \"\"\"Main processing loop\"\"\"\n        while self.running:\n            try:\n                await self._process_item()\n                await asyncio.sleep(self.config.interval)\n            except Exception as e:\n                logger.error(f\"Error in process loop: {e}\")\n                await asyncio.sleep(self.config.interval)\n                \n    async def _process_item(self):\n        \"\"\"Process a single item\"\"\"\n        # Implement your processing logic here\n        logger.info(f\"Processing at {datetime.now().isoformat()}\")\n        \n    async def stop(self):\n        \"\"\"Stop the service\"\"\"\n        self.running = False\n        logger.info(f\"Stopping {self.config.name} service...\")\n        \n        # Cancel all tasks\n        for task in self.tasks:\n            task.cancel()\n            \n        await asyncio.gather(*self.tasks, return_exceptions=True)\n\nasync def main():\n    config = ServiceConfig(name=\"POC\", interval=2.0)\n    service = POCService(config)\n    \n    try:\n        await service.start()\n    except KeyboardInterrupt:\n        await service.stop()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())"
  },
  "go": {
    "api": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n)\n\ntype HealthResponse struct {\n\tMessage   string    `json:\"message\"`\n\tTimestamp time.Time `json:\"timestamp\"`\n\tUptime    float64   `json:\"uptime\"`\n}\n\ntype ExampleRequest struct {\n\tData string `json:\"data\"`\n}\n\ntype ExampleResponse struct {\n\tSuccess bool        `json:\"success\"`\n\tResult  interface{} `json:\"result,omitempty\"`\n\tError   string      `json:\"error,omitempty\"`\n}\n\nvar startTime = time.Now()\n\nfunc healthHandler(w http.ResponseWriter, r *http.Request) {\n\tresponse := HealthResponse{\n\t\tMessage:   \"POC API is running\",\n\t\tTimestamp: time.Now(),\n\t\tUptime:    time.Since(startTime).Seconds(),\n\t}\n\t\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(response)\n}\n\nfunc exampleHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodPost {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\t\n\tvar req ExampleRequest\n\tif err := json.NewDecoder(r.Body).Decode(&req); err != nil {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tjson.NewEncoder(w).Encode(ExampleResponse{\n\t\t\tSuccess: false,\n\t\t\tError:   \"Invalid request body\",\n\t\t})\n\t\treturn\n\t}\n\t\n\t// Process the request here\n\tresult := map[string]interface{}{\n\t\t\"received\":  req.Data,\n\t\t\"processed\": true,\n\t\t\"timestamp\": time.Now(),\n\t}\n\t\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(ExampleResponse{\n\t\tSuccess: true,\n\t\tResult:  result,\n\t})\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/health\", healthHandler)\n\thttp.HandleFunc(\"/api/example\", exampleHandler)\n\t\n\tport := os.Getenv(\"PORT\")\n\tif port == \"\" {\n\t\tport = \"3000\"\n\t}\n\t\n\tfmt.Printf(\"POC server running on port %s\\n\", port)\n\tlog.Fatal(http.ListenAndServe(\":\"+port, nil))\n}",
    "cli": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\tvar (\n\t\tinputFile  = flag.String(\"input\", \"\", \"Input file to process\")\n\t\toutputFile = flag.String(\"output\", \"\", \"Output file (optional)\")\n\t\tverbose    = flag.Bool(\"verbose\", false, \"Enable verbose output\")\n\t)\n\t\n\tflag.Parse()\n\t\n\tif *inputFile == \"\" {\n\t\tflag.Usage()\n\t\tos.Exit(1)\n\t}\n\t\n\tif *verbose {\n\t\tfmt.Printf(\"Reading file: %s\\n\", *inputFile)\n\t}\n\t\n\tcontent, err := ioutil.ReadFile(*inputFile)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error reading file: %v\", err)\n\t}\n\t\n\t// Process content here\n\tprocessed := fmt.Sprintf(\"Processed %d bytes from %s\", len(content), *inputFile)\n\t\n\tif *outputFile != \"\" {\n\t\terr := ioutil.WriteFile(*outputFile, []byte(processed), 0644)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Error writing output: %v\", err)\n\t\t}\n\t\tfmt.Printf(\"Output written to: %s\\n\", *outputFile)\n\t} else {\n\t\tfmt.Println(processed)\n\t}\n}"
  }
}